# 3.E.2: Bigfoot SQL

## Learning Objectives

1. How to create a backend API server with Express, PostgreSQL and Sequelize
2. Connect a frontend app with a backend API server that uses SQL to store and retrieve data

## Introduction

We will use forms and POST requests to save new Bigfoot sightings to our database.

## New Tooling: SQL Clients

SQL clients help us visualise our databases with clickable interfaces without repeatedly typing SQL queries. Rocket recommends [pgAdmin](https://www.pgadmin.org/) for Windows and [Postico](https://eggerapps.at/postico/) for Mac, both of which are free. We are free to use any other SQL clients we may prefer.

1. Windows: [pgAdmin installation instructions](https://stackoverflow.com/questions/45707319/pgadmin-on-windows-10-with-postgres-when-installed-via-bash-on-ubuntu-on-windows/54192456#54192456)
2. Mac: [Postico installation instructions](https://eggerapps.at/postico/)

## Sequelize Setup

Rocket has performed the following Sequelize setup for this Bigfoot exercise, but you may wish to refer back to these instructions for future projects where you need to set up Sequelize on your own.

### Setup Packages

#### Install Sequelize NPM Packages

Install `sequelize` and `pg` to use Sequelize with Postgres in our app.

```
npm i sequelize pg
```

Install `sequelize-cli` in dev dependencies to generate Sequelize model and migration files and run Sequelize migrations that will set up our database schema. We install to dev dependencies because we only need `sequelize-cli` for database setup and not when the app is live; dev dependencies are typically not installed in production. The `-D` flag is for dev dependencies.

```
npm i -D sequelize-cli
```

#### Create Sequelize Folders

Create a `.sequelizerc` file in the root of our repo to tell Sequelize where to store its files. We will use a suggested configuration from the official Sequelize docs.

{% code title=".sequelizerc" %}

```javascript
const path = require("path");

module.exports = {
  config: path.resolve("config", "database.json"),
  "models-path": path.resolve("db", "models"),
  "seeders-path": path.resolve("db", "seeders"),
  "migrations-path": path.resolve("db", "migrations"),
};
```

{% endcode %}

Create Sequelize folders and starter files in the locations specified in `.sequelizerc` using `npx sequelize init`. These will store Sequelize files and configurations that we will need for our application. We will explore these files in more detail below.

```bash
npx sequelize init
```

Verify our Sequelize config file is in `config/database.json` and our `models`, `seeders` and `migrations` folders are in a folder called `db`.

### Configure Database

#### Populate DB config

Update `config/database.js` to contain database settings for the "development" environment, i.e. when we are developing locally. We can delete "test" and "production" settings for now until we need them.

{% code title="config/database.js" %}

```javascript
{
  "development": {
    "username": "my_unix_username",
    "password": null,
    "database": "my_app_development",
    "host": "127.0.0.1",
    "dialect": "postgres"
  }
}
```

{% endcode %}

Replace `my_unix_username` with your local Unix username (use `whoami` to find it) and replace `my_app` in `my_app_development` with the name of your app in snake_case.

**Create DB based on config**

Create the database specified in the config using Sequelize CLI's `db:create` command.

```
npx sequelize db:create
```

We should see output like the following after creating our database on the command line.

```
Sequelize CLI [Node: 16.14.2, CLI: 6.4.1, ORM: 6.20.1]

Loaded configuration file "config/database.json".
Using environment "development".
Database my_app_development created.
```

### Create Models and Migrations

Recall from Rocket's Sequelize submodule that models tell our apps what data they can access, and migrations control our database schema. Our models may change as our apps evolve, and we will need to create new migrations to update our databases with those changes without affecting live data.

Use Sequelize's `model:generate` command to generate a model and initial migration for the `Sighting` model (and `Sightings` table in our DB).

```
npx sequelize model:generate --name Sighting --attributes date:date,location:string,notes:string
```

This should generate output like the following.

```
Sequelize CLI [Node: 16.14.2, CLI: 6.4.1, ORM: 6.20.1]

New model was created at /Users/kai/rocket-code/bootcamp/examples/bigfoot-sql-backend-bootcamp/db/models/sighting.js .
New migration was created at /Users/kai/rocket-code/bootcamp/examples/bigfoot-sql-backend-bootcamp/db/migrations/20220531155824-create-sighting.js .
```

**Run Migration to Create Table**

Migration files specify what changes Sequelize should make to our DB schema. To execute all unexecuted migration files, run Sequelize CLI's db:migrate command.

```
npx sequelize db:migrate
```

`db:migrate` will perform the following.

1. Create a table called SequelizeMeta in database if it doesn't exist yet that records which migrations have run on the database so far
2. Run migration files that have not been run yet, generating relevant tables and columns

## Base

Enable our users to save Bigfoot sightings to our DB. Work in the following order.

### Create New Sighting Form

1. Create a new sighting form that sends a POST request to the server when users submit new sightings.
2. Start with just YEAR and SEASON fields so we don't overwhelm ourselves.
3. Confirm that the form produces requests with the appropriate data by inspecting the request in Chrome DevTools.

### Create Test Requests using Curl and Thunder Client

1. Often we will want to test our server logic by sending requests independent of our frontends. This is so that we don't have to fill out forms and click several buttons every time we wish to send the same request.
2. We will learn 2 ways to send requests outside of our frontends: Curl and Thunder Client.

#### Curl

1. [Curl](https://curl.se) is a command line utility for sending requests.
2. Send a POST request for new Bigfoot sightings using `curl` like the example below. `-d` is for `--data`, and `-X` is for `--request`, allowing us to specify a custom request method different from the default GET method.

   ```
   curl -d "YEAR=1989&SEASON=spring" -X POST http://localhost:3004/sighting
   ```

#### Thunder Client

1. If you haven't already, install Thunder Client from [0.7: Thunder Client](../../0-language-and-tooling/0.7-postman.md).
2. Use TC to create requests and test server responses with a visual interface.

### Add Server Route to Handle Request

{% hint style="info" %}
**Pro Tip: Smaller Test Database**

We may find that using the provided `data.json` with all its sightings slows us down when verifying our server logic. To simplify our workflow, consider using a new, smaller `data.json` for testing purposes. Once we've verified our app works, replace `data.json` with the original full database.
{% endhint %}

1. Create a route to listen for and handle our POST request from Express.
2. Remember to include the [middleware for Express to populate `request.body`](../3.1-express-js/3.1.2-handling-post-requests.md#receive-post-requests-in-express).
3. Before writing other request handler logic, verify our route is receiving the request correctly with `console.log` like the following.

   ```javascript
   console.log(request.body);
   response.send("It worked!");
   ```

4. Use Curl or Thunder Client to confirm our server receives requests correctly.
5. Send the request again with different params to verify params change in `request.body`.

   ```
   curl -d "YEAR=9999999&SEASON=pepper" -X POST http://localhost:3004/sighting
   ```

6. Once we've verified the mechanics of sending and receiving requests, update our request handler in Express to store new sighting data with `jsonFileStorage`.

## Receive POST Requests in Express

1.  Express typically provides POST request data to us in the Express `request` object via the `request.body` attribute. To receive request body data in `request.body` we need to bind the following `urlencoded` middleware to Express above our routes. Read more about the `urlencoded` middleware in Express docs [here](https://expressjs.com/en/api.html#express.urlencoded).

    ```javascript
    app.use(express.urlencoded({ extended: false }));
    ```

## Comfortable

### Add Full Sighting Details

Add the other Bigfoot sighting attributes to our sighting creation form and save them to the DB.

### Redirect After Form Submit

1. Typical app behaviour after entity creation is to redirect the user to a page showing the created entity, i.e. the sighting in our case.
2. Update our server to redirect the user to the correct page after they submit the sighting creation form.

   1. Read how to use Express' redirect functionality [here](https://expressjs.com/en/api.html#res.redirect). Note that `res.send` and `res.redirect` are mutually exclusive, because [both terminate the request-response cycle](https://stackoverflow.com/questions/48813930/res-send-after-res-redirect-in-nodejs).
   2. The redirect URL may look something like the following, where `<INDEX>` is the index of the newly-created sighting.

      ```markup
      http://localhost:3004/sighting/<INDEX>
      ```

## More Comfortable

### Add Sort Forms for Sightings List

1.  Create a form on the sightings list page that sends a GET request with the same sort query parameters from [2.POCE.1: Bigfoot](../3.poce-post-class-exercises/2.poce.1-bigfoot.md#sort-by). The generated request URLs might look like the following.

    ```
    http://localhost:3004/year-sightings?sort=asc
    http://localhost:3004/year-sightings?sort=desc
    ```

2.  Use an HTML `select` tag in the form to allow the user to select "ascending" or "descending" sort params from the dropdown.
3.  Add a similar dropdown for other sort options from [2.POCE.2: Bigfoot EJS](../3.poce-post-class-exercises/2.poce.2-bigfoot-ejs.md#sort-by). These might produce the following URLs.

    ```markup
    http://localhost:3004/?sortBy=year
    http://localhost:3004/?sortBy=state
    ```

## Deployment Introduction

Deploying the [base MVC (and Webpack) app](https://github.com/rocketacademy/webpack-mvc-base-bootcamp) is the same as deploying previous apps to Heroku with one difference- the database.

When using Sequelize we need to have different configs for connecting to the Heroku Postgres instance. Those configs are here: [https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/config/config.js#L9-L19](https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/config/config.js#L9-L19)

```javascript
// ...
//
production: {
  use_env_variable: 'DATABASE_URL',
  dialect: 'postgres',
  protocol: 'postgres',
  dialectOptions: {
    ssl: { // https://github.com/sequelize/sequelize/issues/12083
      require: true,
      rejectUnauthorized: false,
    },
  },
},
// ...
```

and here: [https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/models/index.mjs#L12-L24](https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/models/index.mjs#L12-L24)

```javascript
if (env === "production") {
  // Break apart the Heroku database url and rebuild the configs we need
  const { DATABASE_URL } = process.env;
  const dbUrl = url.parse(DATABASE_URL);
  const username = dbUrl.auth.substr(0, dbUrl.auth.indexOf(":"));
  const password = dbUrl.auth.substr(
    dbUrl.auth.indexOf(":") + 1,
    dbUrl.auth.length
  );
  const dbName = dbUrl.path.slice(1);
  const host = dbUrl.hostname;
  const { port } = dbUrl;
  config.host = host;
  config.port = port;
  sequelize = new Sequelize(dbName, username, password, config);
}
```

These are all included configs that don't need to be changed.

## Initializing the DB

To get your Sequelize database running on Heroku, run the Sequelize commands within the Heroku system. (No need to create the database, that's already been done when you provision the Postgres add-on.)

```
heroku run npx sequelize-cli db:migrate
```

```
heroku run npx sequelize-cli db:seed:all
```

## Date Types Introduction

Postgres has several data types to represent time data. The following are some best practices for dealing with this data. Read more on Postgres date and time data types [here](https://www.postgresql.org/docs/current/datatype-datetime.html).

## SQL Tables Should Have `created_at`

Most of our tables should have a column called `created_at`. This is a timestamp that shows when each row was created. This is easy to set as a column in our `CREATE TABLE` statements.

```sql
CREATE TABLE recipes (
    id            SERIAL PRIMARY KEY,
    label         TEXT,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

When we create a new row in this table, Postgres will set a timestamp of when we inserted the row.

```sql
INSERT INTO recipes (label) VALUES ('Udon');
```

When we retrieve the record we see the `created_at` value is set automatically.

```sql
SELECT * FROM recipes;
```

## TIMESTAMPTZ as Default Datetime Data Type

The Postgres date data type with the most information in it is TIMESTAMPTZ. As a best practice we should set the database column to this specific type. The value put in the database is set to the date and timezone _**at the computer that it's running on**._

If your app never deals with saving and displaying data in different timezones then you may never need this data, but it doesn't cause any problems to record it. If the scope of your app expands later, it would be impossible to capture or properly deal with this data.

The author of the `pg` library suggests using TIMESTAMPTZ[ here](https://node-postgres.com/features/types#date--timestamp--timestamptz). More information on JavaScript applications needing timezone information[ here.](https://medium.com/@toastui/handling-time-zone-in-javascript-547e67aa842d)

## Forms to Edit TIMESTAMPTZ Data

For `created_at` data, which records the date, time and timezone of a row, we don't have any easy way to render that date data into an edit form (although in real life you would probably never want to edit this information).

If we did want to render an edit form for this data we would need to render a separate form for each piece, i.e, one input for data, another for time, another for timezone. The fundamental problem is that there is no such _**HTML**_ form which can properly set date and time together.

We'll get around this limitation of HTML forms later when we can do DOM manipulation again in the next module. Note that there exists a `datetime-local` input type in HTML but that [it is not cross-browser compatible.](https://caniuse.com/mdn-html_elements_input_input-datetime-local)

## Avoid TIMESTAMPTZ for User-Generated Data (For Now)

Given the above limitation on rendering and capturing date and time data in pure HTML forms, we can minimise headache by using the `DATE` data type in our tables for user-generated date data.

```sql
CREATE TABLE sightings (
    id            SERIAL PRIMARY KEY,
    description   TEXT,
    date          DATE,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Note in the `sightings` example above we make the distinction between `created_at`, the date the row was created in the database, and `date`, the date of the UFO sighting. `created_at` is of type `TIMESTAMPTZ` because it is auto-generated and does not require a form input.

### Capturing Date Data in Forms

For dates (not including time) we can use the `date` input type in a form. In production applications this would also not be ideal, since `date` input types are also not well supported (about 90%), but they are much more prevalent than the `datetime` input type. See browser compatibility of the `date` input type [here](https://caniuse.com/mdn-html_elements_input_input-date).

```markup
<input type="date" name="date"/>
```

Because the `DATE` type in the Postgres table we specified above matches the input format we specified in the input form, we can simply pass what's in `request.body.date` right into the database.

```javascript
app.post("/sightings", (request, response) => {
  const sightingValues = [request.body.description, request.body.date];

  const sightingInsertQuery =
    "INSERT INTO sightings (description, date) VALUES ($1, $2) RETURNING *";

  pool.query(sightingInsertQuery, sightingValues, (error, result) => {
    if (error) {
      console.log(error);
      response.status(501).send("error!");
      return;
    }

    console.log(result.rows);
    response.send("success");
  });
});
```

### Date Output Format

The `pg` npm library processes the data coming out of the database and transforms it into native JavaScript types. When we get the value of a DATE SQL type out of the database it's a [JavaScript Date Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date). We can call any of the methods on this value that are specified in the JS Date documentation.

```javascript
app.get("/sightings", (request, response) => {
  const query = "SELECT * from sightings";

  pool.query(query).then((result) => {
    // print out all the dates in the database
    const allSightingDates = result.rows.map((sighting) => {
      console.log(sighting.date);

      // change this Date object into a string value
      return sighting.date.toString();
    });

    response.send(allSightingDates);
  });
});
```

## Advanced Date Formatting

If we want to format the date in a fancier way we can use the `moment` library.

```javascript
npm install moment
```

```javascript
import moment from "moment";
```

Format date data by the amount of time from now.

```javascript
// ...

// print out all the dates in the database
const allSightingDates = result.rows.map((sighting) => {
  console.log(sighting.date);

  // change this Date object into a string value
  // .from returns a "ago" string
  return moment(sighting.date).from();
});

// ...
```

The output would be something like this.

```javascript
["11 days ago", "117 years ago"];
```

See the [`moment` docs](https://momentjs.com/docs/#/displaying/) on how to output dates with `moment`. Note that `moment` will also work with the `TIMESTAMPTZ` data type from the `created_at` column and any date with timezone data inside it.

## Current Options for Storing Time Data

If your app requires time data, based on the technologies we have learned so far, we have a few options. We'll look at more advanced date time input methods with browser-side JavaScript in the next module.

1. Disregard cross-browser compatibility and use the `datetime-local` input type. Chrome supports `datetime-local` and the field value can be inserted directly into a Postgres `TIMESTAMPTZ` field.
2. Use the `date` input type and create a separate input field for time data. Store time data in Postgres using a separate column. Example [here](https://stackoverflow.com/questions/538739/best-way-to-store-time-hhmm-in-a-database). In production applications we would always want to store timezone data, but in Coding Bootcamp Module 3 it's not recommended due to input limitations.
3. Avoid time input altogether in your application, and only support date input.
