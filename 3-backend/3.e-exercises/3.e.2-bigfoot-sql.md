# 3.E.2: Bigfoot SQL

## Introduction

Use forms and POST requests to save new Bigfoot sightings to our DB.

## Setup

### SQL Clients

SQL clients help us visualise our databases with clickable interfaces without repeatedly typing SQL queries. There are many SQL clients we can use; Rocket recommends [pgAdmin](https://www.pgadmin.org/) for Windows and [Postico](https://eggerapps.at/postico/) for Mac, both of which are free.

#### Windows

From the instructions here: [https://stackoverflow.com/questions/45707319/pgadmin-on-windows-10-with-postgres-when-installed-via-bash-on-ubuntu-on-windows](https://stackoverflow.com/questions/45707319/pgadmin-on-windows-10-with-postgres-when-installed-via-bash-on-ubuntu-on-windows)

#### Mac

Download, install, and open [Postico](https://eggerapps.at/postico/).

#### Alternatives

If we prefer a different interface we can try other Postgres SQL clients. They generally behave the same but with different user interfaces.

1. [https://wiki.postgresql.org/wiki/PostgreSQL\_Clients](https://wiki.postgresql.org/wiki/PostgreSQL\_Clients)
2. [https://www.slant.co/topics/7283/\~gui-tools-for-postgresql-on-windows](https://www.slant.co/topics/7283/\~gui-tools-for-postgresql-on-windows)

## Receive POST Requests in Express

1.  Express typically provides POST request data to us in the Express `request` object via the `request.body` attribute. To receive request body data in `request.body` we need to bind the following `urlencoded` middleware to Express above our routes. Read more about the `urlencoded` middleware in Express docs [here](https://expressjs.com/en/api.html#express.urlencoded).

    ```javascript
    app.use(express.urlencoded({ extended: false }));
    ```

## Base

Enable our users to save Bigfoot sightings to our DB. Work in the following order.

### Create New Sighting Form

1. Create a new sighting form that sends a POST request to the server when users submit new sightings.
2. Start with just YEAR and SEASON fields so we don't overwhelm ourselves.
3. Confirm that the form produces requests with the appropriate data by inspecting the request in Chrome DevTools.

### Create Test Requests using Curl and Thunder Client

1. Often we will want to test our server logic by sending requests independent of our frontends. This is so that we don't have to fill out forms and click several buttons every time we wish to send the same request.
2. We will learn 2 ways to send requests outside of our frontends: Curl and Thunder Client.

#### Curl

1. [Curl](https://curl.se) is a command line utility for sending requests.
2.  Send a POST request for new Bigfoot sightings using `curl` like the example below. `-d` is for `--data`, and `-X` is for `--request`, allowing us to specify a custom request method different from the default GET method.

    ```
    curl -d "YEAR=1989&SEASON=spring" -X POST http://localhost:3004/sighting
    ```

#### Thunder Client

1. If you haven't already, install Thunder Client from [0.7: Thunder Client](../../0-language-and-tooling/0.7-postman.md).
2. Use TC to create requests and test server responses with a visual interface.

### Add Server Route to Handle Request

{% hint style="info" %}
**Pro Tip: Smaller Test Database**

We may find that using the provided `data.json` with all its sightings slows us down when verifying our server logic. To simplify our workflow, consider using a new, smaller `data.json` for testing purposes. Once we've verified our app works, replace `data.json` with the original full database.
{% endhint %}

1. Create a route to listen for and handle our POST request from Express.
2. Remember to include the [middleware for Express to populate `request.body`](../3.1-express-js/3.1.2-handling-post-requests.md#receive-post-requests-in-express).
3.  Before writing other request handler logic, verify our route is receiving the request correctly with `console.log` like the following.

    ```javascript
    console.log(request.body);
    response.send("It worked!");
    ```
4. Use Curl or Thunder Client to confirm our server receives requests correctly.
5.  Send the request again with different params to verify params change in `request.body`.

    ```
    curl -d "YEAR=9999999&SEASON=pepper" -X POST http://localhost:3004/sighting
    ```
6. Once we've verified the mechanics of sending and receiving requests, update our request handler in Express to store new sighting data with `jsonFileStorage`.

## Comfortable

### Add Full Sighting Details

Add the other Bigfoot sighting attributes to our sighting creation form and save them to the DB.

### Redirect After Form Submit

1. Typical app behaviour after entity creation is to redirect the user to a page showing the created entity, i.e. the sighting in our case.
2. Update our server to redirect the user to the correct page after they submit the sighting creation form.
   1. Read how to use Express' redirect functionality [here](https://expressjs.com/en/api.html#res.redirect). Note that `res.send` and `res.redirect` are mutually exclusive, because [both terminate the request-response cycle](https://stackoverflow.com/questions/48813930/res-send-after-res-redirect-in-nodejs).
   2.  The redirect URL may look something like the following, where `<INDEX>` is the index of the newly-created sighting.

       ```markup
       http://localhost:3004/sighting/<INDEX>
       ```

## More Comfortable

### Add Sort Forms for Sightings List

1.  Create a form on the sightings list page that sends a GET request with the same sort query parameters from [2.POCE.1: Bigfoot](../3.poce-post-class-exercises/2.poce.1-bigfoot.md#sort-by). The generated request URLs might look like the following.

    ```
    http://localhost:3004/year-sightings?sort=asc
    http://localhost:3004/year-sightings?sort=desc
    ```
2. Use an HTML `select` tag in the form to allow the user to select "ascending" or "descending" sort params from the dropdown.
3.  Add a similar dropdown for other sort options from [2.POCE.2: Bigfoot EJS](../3.poce-post-class-exercises/2.poce.2-bigfoot-ejs.md#sort-by). These might produce the following URLs.

    ```markup
    http://localhost:3004/?sortBy=year
    http://localhost:3004/?sortBy=state
    ```





## Introduction

Postgres has several data types to represent time data. The following are some best practices for dealing with this data. Read more on Postgres date and time data types [here](https://www.postgresql.org/docs/current/datatype-datetime.html).

## SQL Tables Should Have `created_at`

Most of our tables should have a column called `created_at`. This is a timestamp that shows when each row was created. This is easy to set as a column in our `CREATE TABLE` statements.

```sql
CREATE TABLE recipes (
    id            SERIAL PRIMARY KEY,
    label         TEXT,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

When we create a new row in this table, Postgres will set a timestamp of when we inserted the row.

```sql
INSERT INTO recipes (label) VALUES ('Udon');
```

When we retrieve the record we see the `created_at` value is set automatically.

```sql
SELECT * FROM recipes;
```

## TIMESTAMPTZ as Default Datetime Data Type

The Postgres date data type with the most information in it is TIMESTAMPTZ. As a best practice we should set the database column to this specific type. The value put in the database is set to the date and timezone _**at the computer that it's running on**._

If your app never deals with saving and displaying data in different timezones then you may never need this data, but it doesn't cause any problems to record it. If the scope of your app expands later, it would be impossible to capture or properly deal with this data.

The author of the `pg` library suggests using TIMESTAMPTZ[ here](https://node-postgres.com/features/types#date--timestamp--timestamptz). More information on JavaScript applications needing timezone information[ here.](https://medium.com/@toastui/handling-time-zone-in-javascript-547e67aa842d)

## Forms to Edit TIMESTAMPTZ Data

For `created_at` data, which records the date, time and timezone of a row, we don't have any easy way to render that date data into an edit form (although in real life you would probably never want to edit this information).

If we did want to render an edit form for this data we would need to render a separate form for each piece, i.e, one input for data, another for time, another for timezone. The fundamental problem is that there is no such _**HTML**_ form which can properly set date and time together.

We'll get around this limitation of HTML forms later when we can do DOM manipulation again in the next module. Note that there exists a `datetime-local` input type in HTML but that [it is not cross-browser compatible.](https://caniuse.com/mdn-html\_elements\_input\_input-datetime-local)

## Avoid TIMESTAMPTZ for User-Generated Data (For Now)

Given the above limitation on rendering and capturing date and time data in pure HTML forms, we can minimise headache by using the `DATE` data type in our tables for user-generated date data.

```sql
CREATE TABLE sightings (
    id            SERIAL PRIMARY KEY,
    description   TEXT,
    date          DATE,
    created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

Note in the `sightings` example above we make the distinction between `created_at`, the date the row was created in the database, and `date`, the date of the UFO sighting. `created_at` is of type `TIMESTAMPTZ` because it is auto-generated and does not require a form input.

### Capturing Date Data in Forms

For dates (not including time) we can use the `date` input type in a form. In production applications this would also not be ideal, since `date` input types are also not well supported (about 90%), but they are much more prevalent than the `datetime` input type. See browser compatibility of the `date` input type [here](https://caniuse.com/mdn-html\_elements\_input\_input-date).

```markup
<input type="date" name="date"/>
```

Because the `DATE` type in the Postgres table we specified above matches the input format we specified in the input form, we can simply pass what's in `request.body.date` right into the database.

```javascript
app.post("/sightings", (request, response) => {
  const sightingValues = [request.body.description, request.body.date];

  const sightingInsertQuery =
    "INSERT INTO sightings (description, date) VALUES ($1, $2) RETURNING *";

  pool.query(sightingInsertQuery, sightingValues, (error, result) => {
    if (error) {
      console.log(error);
      response.status(501).send("error!");
      return;
    }

    console.log(result.rows);
    response.send("success");
  });
});
```

### Date Output Format

The `pg` npm library processes the data coming out of the database and transforms it into native JavaScript types. When we get the value of a DATE SQL type out of the database it's a [JavaScript Date Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global\_Objects/Date). We can call any of the methods on this value that are specified in the JS Date documentation.

```javascript
app.get("/sightings", (request, response) => {
  const query = "SELECT * from sightings";

  pool.query(query).then((result) => {
    // print out all the dates in the database
    const allSightingDates = result.rows.map((sighting) => {
      console.log(sighting.date);

      // change this Date object into a string value
      return sighting.date.toString();
    });

    response.send(allSightingDates);
  });
});
```

## Advanced Date Formatting

If we want to format the date in a fancier way we can use the `moment` library.

```javascript
npm install moment
```

```javascript
import moment from "moment";
```

Format date data by the amount of time from now.

```javascript
// ...

// print out all the dates in the database
const allSightingDates = result.rows.map((sighting) => {
  console.log(sighting.date);

  // change this Date object into a string value
  // .from returns a "ago" string
  return moment(sighting.date).from();
});

// ...
```

The output would be something like this.

```javascript
["11 days ago", "117 years ago"];
```

See the [`moment` docs](https://momentjs.com/docs/#/displaying/) on how to output dates with `moment`. Note that `moment` will also work with the `TIMESTAMPTZ` data type from the `created_at` column and any date with timezone data inside it.

## Current Options for Storing Time Data

If your app requires time data, based on the technologies we have learned so far, we have a few options. We'll look at more advanced date time input methods with browser-side JavaScript in the next module.

1. Disregard cross-browser compatibility and use the `datetime-local` input type. Chrome supports `datetime-local` and the field value can be inserted directly into a Postgres `TIMESTAMPTZ` field.
2. Use the `date` input type and create a separate input field for time data. Store time data in Postgres using a separate column. Example [here](https://stackoverflow.com/questions/538739/best-way-to-store-time-hhmm-in-a-database). In production applications we would always want to store timezone data, but in Coding Bootcamp Module 3 it's not recommended due to input limitations.
3. Avoid time input altogether in your application, and only support date input.
