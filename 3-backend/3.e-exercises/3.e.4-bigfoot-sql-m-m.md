# 3.E.4: Bigfoot SQL M-M

## Learning Objectives

1. Understand how to set up M-M relationships in a SQL database using models and migrations with foreign keys and junction tables
2. Understand how to query M-M relationship data with Sequelize
3. Understand how to access data in the junction table using Sequelize

## Introduction

We will add categories to our Bigfoot sightings to make it easier for researchers to categorise sighting data. There will be an M-M relationship between categories and sightings.

## Setup

If you haven't already, complete Exercise Setup for the prior Bigfoot SQL exercise. This exercise will use the same frontend and backend repos and the same setup.

## Base: Add Categories to Sightings

We will follow a similar workflow to Bigfoot SQL 1-M in adding a new model, routes and frontend elements to support the categories feature.

### Create `Category` model, associate with `Sighting`

Create a new model `Category` to store sighting categories with `npx sequelize model:generate`, which will also create a corresponding migration. Reminder that our model names are Title Case with first letter capitalised. `Category` should have a `name` attribute of type `string`.

Update `Category` and `Sighting` models to include a `belongsToMany` association from each to the other, using the `through` option to specify junction table name `SightingCategories`.

Create a new migration file for the `SightingCategories` junction table with `npx sequelize migration:generate`. Name the migration file with the same convention as the previous migration files, e.g. `create-sightingcategories`.

Update the migration for `SightingCategories` to create the junction table with `id`, `SightingId`, `CategoryId`, `createdAt` and `updatedAt` attributes. Reference past migration files for `Sightings` and `Comments` tables for format of boilerplate attributes like `id`, `createdAt` and `updatedAt` and foreign key attributes like `SightingId` and `CategoryId`. Remember to include the reverse instructions to drop the table in the `down` function, and verify our table name strings are accurate.

Reminder to update file extensions to be `.cjs` so that our app that expects ES6 modules by default can execute files with CommonJS syntax.

Run migrations with `npx sequelize db:migrate` and verify in our SQL client that our tables are what we expect. This would be a good time to commit changes to keep our commits small and with the app in working condition. Remember to include a short and descriptive commit message.

### Write backend routes for categories

#### Clarify app requirements before creating backend routes

Before we start writing routes, let's understand app requirements and decide on inputs and outputs for our categories APIs.&#x20;

We will need to add and remove categories when creating or editing sightings. We will use the [React Select library](https://react-select.com/home) in our frontend for users to select categories.&#x20;

The above requirements mean we need 2 new routes: one to retrieve all categories and another to create a new category. We will also need to update our sighting creation route and sighting edit route (if any) to associate specified categories with sightings.

Let's start by creating the new routes to retrieve and create categories.

#### Create routes to retrieve and create categories

Create a GET route to `/categories` to retrieve categories and a POST route to `/categories` to create a new category. The post route should read the category name from `req.body.name`.

#### Update sighting creation and edit routes (if any) to associate relevant categories with the relevant sighting

We want to remove associations with any no-longer-associated categories and add associations to all newly-associated categories. Luckily,  [Sequelize `belongsToMany` relationship methods](https://sequelize.org/docs/v6/core-concepts/assocs/#foobelongstomanybar--through-baz-) provide us a convenient `fooInstance.setBars()` relationship method to do exactly this.

Unfortunately we are not yet sure exactly in what format our frontend will send category IDs to our backend, so let's come back to this task later.

#### Test routes with Thunder Client

Test that our GET and POST routes to `/categories` work with Thunder Client before moving on.

### Update frontend to select categories on sighting creation

Update our new sighting form to add a categories field powered by [React Select](https://react-select.com/home). React Select will provide a controlled form input whose value we control with a state variable. On form submit we will send the value of the state variable to our backend just like all other form inputs.

#### Add categories to our database using Thunder Client

To make our form more realistic, add 3 categories to our database with POST requests to `/categories` via Thunder Client. These categories can be `rain`, `mountain`, `woods` or any other categories you deem relevant.

#### Allow users to select categories

Install `react-select` as per [React Select's Getting Started docs](https://react-select.com/home#getting-started).

Include `Select` as a form field in our new sighting form. Rocket's reference implementation looks like the following.

{% code title="NewSightingForm.js" %}
```jsx
<Select
  isMulti
  options={categoryOptions}
  value={selectedCategories}
  onChange={handleSelectChange}
/>
```
{% endcode %}

1. `isMulti` tells `Select` to accept multiple inputs
2. `options` are the category options in our select field that we retrieve with `useEffect`. Remember to pass `[]` as 2nd param to `useEffect` so the effect only runs on component mount!
3. `value` is the local state we use to control this form field. `selectedCategories` is local state we created with `useState`.
4. `onChange` is the callback method we use to update local state when the value of the select field changes. Unlike `onChange` for regular HTML input fields, `onChange` for React Select passes an array of selected values in `{ value, label }` format as the 1st parameter to the callback function. This means we will need to create a custom `handleSelectChange` function separate from any `handleChange` functions we created for the other input fields. React Select `onChange` [API documentation here](https://react-select.com/props#api) (search for "onChange").

Rocket also included the following `useEffect` hook and logic to generate category options that may be helpful for you. `allCategories` is local state we created with `useState`.

{% code title="NewSightingForm.js" %}
```jsx
useEffect(() => {
  axios.get(`${BACKEND_URL}/categories`).then((response) => {
    setAllCategories(response.data);
  });
  // Only run this effect on component mount
}, []);

const categoryOptions = allCategories.map((category) => ({
  // value is what we store
  value: category.id,
  // label is what we display
  label: category.name,
}));
```
{% endcode %}

Implement the above first, run our backend and frontend servers locally and verify we can receive all category options in our select field.

{% hint style="info" %}
**Control `Select` field colours**

If you find that the `Select` field's colours are off, e.g. white text on white background, you can customise the `Select` field's styles relatively easily.

Rocket created the following `Select` style object in our sighting creation form.

```jsx
// Make text black in Select field
const selectFieldStyles = {
  option: (provided) => ({
    ...provided,
    color: "black",
  }),
};
```

We then applied that style to our `Select` element like below.

```jsx
<Select
  isMulti
  styles={selectFieldStyles}
  options={categoryOptions}
  value={selectedCategories}
  onChange={handleSelectChange}
/>
```

[React Select's styling documentation](https://react-select.com/styles#provided-styles-and-state) provides a quick overview.
{% endhint %}

#### Update frontend and backend submit logic to create new sightings with relevant category associations

Update our `handleSubmit` function to include selected category IDs when submitting new sighting data to our backend.

We now know our backend POST route to `/sightings` will receive categories as an array of category IDs and can complete that route. In the route middleware function, retrieve relevant categories (you may find [this Stack Overflow answer](https://stackoverflow.com/a/25028339) helpful) and associate them with the new sighting with the Sequelize `belongsToMany` `fooInstance.setBars()` (i.e. `newSighting.setCategories()`) relationship method.

Verify we can associate the new sighting with categories on submit. Great work!

### Display categories next to sightings

Last but not least, let's display any associated categories next to sightings on the home page and the sighting-specific page.

#### Update routes to retrieve sightings to also retrieve category data

Update our backend routes that retrieve sightings (`/sightings` and `/sightings/:sightingId`) to also retrieve associated categories. We can do this with eager loading by specifying `include: Category` as  query option. Review Sequelize's [introduction to eager loading](https://sequelize.org/docs/v6/core-concepts/assocs/#fetching-associations---eager-loading-vs-lazy-loading) and [`findByPk` API reference](https://sequelize.org/api/v6/class/src/model.js\~model#static-method-findByPk) for examples and docs.&#x20;

Verify with Thunder Client that these routes return category data together with sighting data.

#### Display category data next to sightings on homepage and sighting-specific page

Almost there! Now that our sighting retrieval routes respond with category data, update our UI logic to render associated categories next to each sighting on the homepage and sighting-specific pages.&#x20;

Congratulations!

## Comfortable: Create New Categories

Use [React Select Creatable](https://react-select.com/home#creatable) features to allow users to create new categories.

## More Comfortable: Add Category Intensity

## Submission

Submit pull requests to the `main` branches of Rocket's Bigfoot Frontend and Bigfoot SQL Backend repos respectively, and share your PR links in your section Slack channel.

## Deployment

### Heroku deploy instructions

Deploying the [base MVC (and Webpack) app](https://github.com/rocketacademy/webpack-mvc-base-bootcamp) is the same as deploying previous apps to Heroku with one difference- the database.

When using Sequelize we need to have different configs for connecting to the Heroku Postgres instance. Those configs are here: [https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/config/config.js#L9-L19](https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/config/config.js#L9-L19)

```javascript
// ...
//
production: {
  use_env_variable: 'DATABASE_URL',
  dialect: 'postgres',
  protocol: 'postgres',
  dialectOptions: {
    ssl: { // https://github.com/sequelize/sequelize/issues/12083
      require: true,
      rejectUnauthorized: false,
    },
  },
},
// ...
```

and here: [https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/models/index.mjs#L12-L24](https://github.com/rocketacademy/webpack-mvc-base-bootcamp/blob/main/models/index.mjs#L12-L24)

```javascript
if (env === "production") {
  // Break apart the Heroku database url and rebuild the configs we need
  const { DATABASE_URL } = process.env;
  const dbUrl = url.parse(DATABASE_URL);
  const username = dbUrl.auth.substr(0, dbUrl.auth.indexOf(":"));
  const password = dbUrl.auth.substr(
    dbUrl.auth.indexOf(":") + 1,
    dbUrl.auth.length
  );
  const dbName = dbUrl.path.slice(1);
  const host = dbUrl.hostname;
  const { port } = dbUrl;
  config.host = host;
  config.port = port;
  sequelize = new Sequelize(dbName, username, password, config);
}
```

These are all included configs that don't need to be changed.

### Initialising the DB

To get your Sequelize database running on Heroku, run the Sequelize commands within the Heroku system. (No need to create the database, that's already been done when you provision the Postgres add-on.)

```
heroku run npx sequelize-cli db:migrate
```

```
heroku run npx sequelize-cli db:seed:all
```

## Reference Solution

Here is reference code for the frontend and the backend for this exercise, and here is a reference deployment. You can do better!
