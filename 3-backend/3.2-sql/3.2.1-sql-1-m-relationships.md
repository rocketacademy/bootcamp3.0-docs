# 3.2.1: SQL 1-M Relationships

## Introduction

![Each category can have many recipes. Each recipe belongs to at most 1 category.](../.gitbook/assets/one-to-many.jpg)

In SQL we can create a relationship between two tables by referencing the primary key of one table in another column on a different table. In this example we are giving each recipe a category. The name of the category is stored on a different table.

The udon recipe is vegan, the pasta recipe is vegan and the mee pok recipe is keto. Another way to phrase it would be that the vegan recipes are udon and pasta, and the keto recipe is mee pok. **The relationship is called one-to-many because a recipe has one category and a category has many recipes.**

At first this may seem less efficient than simply putting the name of the category into the recipe table (like we had in the noodle recipe JSON). But with SQL we can structure our data much more strictly.

**Noodle Recipe App JSON Format**

```javascript
{
  "recipes": [
    {
      "label": "Udon",
      "category": "vegan"
    },
    {
      "label": "Mee Pok",
      "category": "banana"
    }
  ]
}
```

In our noodle recipe app's JSON we had a category structure that was _implicit_, i.e. there was no master list of categories. With SQL and the one-to-many relationship we will ensure that recipes can only belong to one of a set number of categories that already exist.

## Foreign Keys

Foreign keys are values that reference a primary key in another table. In this case, `category_id` is a foreign key in the `recipes` table that references the `id` primary key in the `categories` table, such that recipes can be linked to categories.

For one-to-many relationships, there will only be a foreign key on 1 table. In our case, this is the `recipes` table. This is because categories can have multiple recipes, but each recipe can only have 1 category. Thus, we store `category_id` in the `recipes` table instead of trying to store multiple recipe IDs per category in the `categories` table.

{% hint style="warning" %}
There is also a Postgres data type called foreign key, but we won't use this for now to keep our applications simple. This Postgres foreign key refers to a database application server feature that throws errors if foreign key rules are violated.
{% endhint %}

## DB Setup Examples

### Create Tables

```sql
CREATE TABLE recipes (id SERIAL PRIMARY KEY, label TEXT, category_id INTEGER);
CREATE TABLE categories (id SERIAL PRIMARY KEY, name TEXT);
```

{% hint style="info" %}
`SERIAL` data type is an auto-incrementing integer data type in Postgres, commonly used for `id` fields. Read more about `SERIAL` [here](https://www.postgresqltutorial.com/postgresql-data-types/).
{% endhint %}

### Create Records

```sql
INSERT INTO categories (name) VALUES ('vegan');
INSERT INTO categories (name) VALUES ('keto');
INSERT INTO categories (name) VALUES ('nut free');
```

### Check IDs

```sql
SELECT * FROM categories;
```

### Create Recipes and Associate with Categories

```sql
INSERT INTO recipes (label, category_id) VALUES ('Udon', 1);
INSERT INTO recipes (label, category_id) VALUES ('Mee Pok', 2);
INSERT INTO recipes (label, category_id) VALUES ('Pasta', 1);
```

## DB Query Examples

### Get All Vegan Recipes

```sql
SELECT * FROM recipes WHERE category_id=1;
```

### Get Udon Category Name

We saw that the Udon Recipe belongs to Category 1 from the previous query.

```sql
SELECT * FROM categories WHERE id=1;
```



## Introduction

When we create new data and wish to associate that data to data in other tables, such as creating new recipes and associating them to categories, we need to have the user input the selected category when they create a recipe.

## Input ID Implementation

The na√Øve way to do this is to create another text input for the user to input the relevant category's ID, but this isn't great because the user may not know what the categories are and what the categories' IDs are. We want to give the user the ability to select from all the possible categories and for the user not to have to deal with the IDs.

```html
<form action="/recipe" method="POST">
  <input type="text" name="label" />
  <input type="text" name="category_id" />
  <input type="submit" value="Submit" />
</form>
```

## Select from Dropdown Implementation

A recipe can only have one category, and the user has to choose from available categories, so we'll do this with a dropdown menu. A dropdown menu facilitates choosing from several selections, and our dropdown will only allow a single selection.

We need to populate this dropdown with all categories in the DB, so before we render the form we'll do a SQL query to get them.

## Query for Categories to Render Dropdown

When we send a GET request to render the create recipe form, we also query the DB for a list of all categories.

**index.js**

```javascript
app.get("/recipe/new", (request, response) => {
  pool.query("SELECT * from categories", (error, result) => {
    const data = {
      categories: result.rows,
    };
    response.render("recipe/new", data);
  });
});
```

## Render Dropdown

We can set the ID of each category in `option` tags in our form. The user never has to know which category names map to which category IDs.

**recipe/new.ejs**

```markup
<form action="/recipe" method="POST">
  <select name="category_id">
    <% categories.forEach((category) => { %>
    <option value="<%= category.id %>"><%= category.name %></option>
    <% }); %>
  </select>
  <input type="text" name="label" />
  <input type="submit" value="Submit" />
</form>
```
