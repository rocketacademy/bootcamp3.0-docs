# 3.2.2: SQL M-M Relationships

## Introduction

In [2.5.1.2: SQL Relationships (One to Many)](2.5.1.2-sql-relationships-one-to-many.md) we learned how to associate 2 tables to each other using foreign keys. This created a relationship in which one row in a table (e.g. `categories`) could be referenced multiple times in another table (e.g. `recipes`).

![Recap of a one-to-many SQL relationship](../../.gitbook/assets/one-to-many.jpg)

We will now learn to create relationships where entries in _both_ associated tables can be referenced multiple times in the associated table.

## Many-to-Many Recipes and Categories

To implement a many-to-many relationship with `recipes` and `categories`, one idea might be to store multiple category IDs inside the `category_id` column in the `recipes` table, something like the following. However, a rigid rule of SQL is that we should never put more than one conceptual piece of data in a cell (i.e. no arrays or JS Objects), thus SQL convention is to create a 3rd table instead. This rule is so that SQL can easily search its tables for the data that it needs without looking into arrays or objects, because the SQL language does not support loops or object dereferencing.

**Idea: Store Multiple Category IDs in `recipes` Table**

```javascript
{
  "label": "Mee Pok",
  "category_id": [1, 2]
}
```

The 3rd table used for many-to-many relationships holds relationship data. A row in this table will associate an entry in 1 table with an entry in another, and potential store other information about the relationship between those 2 entries.

We will redo our Recipe App from before, where the new app enables both categories to have many recipes AND recipes to have many categories.

![Sample DB Schema for Recipe App with Many-to-Many Relationship](../../.gitbook/assets/many-many.jpg)

## Sample Implementation

### Create Tables

```sql
CREATE TABLE recipes (id SERIAL PRIMARY KEY, label TEXT);
CREATE TABLE categories (id SERIAL PRIMARY KEY, name TEXT);
CREATE TABLE recipe_categories (id SERIAL PRIMARY KEY, recipe_id INTEGER, category_id INTEGER);
```

### Create Categories

```sql
INSERT INTO categories (name) VALUES ('vegan');
INSERT INTO categories (name) VALUES ('keto');
INSERT INTO categories (name) VALUES ('nut free');
```

### Create Recipes

```sql
INSERT INTO recipes (label) VALUES ('Udon');
INSERT INTO recipes (label) VALUES ('Mee Pok');
INSERT INTO recipes (label) VALUES ('Pasta');
```

### Check IDs

```sql
SELECT * FROM categories;
SELECT * FROM recipes;
```

### Create Associations Between Recipes and Categories

Give Udon the Vegan and Keto categories, and give Mee Pok the Keto category.

```sql
INSERT INTO recipe_categories (recipe_id, category_id) VALUES (1, 1);
INSERT INTO recipe_categories (recipe_id, category_id) VALUES (1, 2);
INSERT INTO recipe_categories (recipe_id, category_id) VALUES (2, 1);
```

### Get All Vegan Relation Records by Category ID

```sql
SELECT * FROM recipe_categories WHERE category_id=1;
```

### Get All Vegan Recipes by Category ID

```sql
SELECT recipes.id, recipes.label, recipe_categories.category_id, recipe_categories.recipe_id
FROM recipes
INNER JOIN recipe_categories
ON recipe_categories.recipe_id = recipes.id
WHERE recipe_categories.category_id = 1;
```

### Get Udon Category Relation Records by Recipe ID

```sql
SELECT * FROM recipe_categories WHERE recipe_id=1;
```

### Get Udon Categories by Recipe ID

```sql
SELECT categories.id, categories.name, recipe_categories.category_id, recipe_categories.recipe_id
FROM categories
INNER JOIN recipe_categories
ON recipe_categories.category_id = categories.id
WHERE recipe_categories.recipe_id = 1;
```

## Further Reading

Past students have found [this video](https://www.youtube.com/watch?v=1eUn6lsZ7c4) helpful in introducing many-to-many relationships.



## Introduction

One added complexity with many-to-many relationships is that form submissions need to update the join table that facilitates the many-to-many relationship. In this example we'll construct a form that associates a recipe with multiple categories by creating a set of rows in `recipe_categories`.

Unlike with the [one-to-many example](../3.2.3-sql-techniques/2.5.3.2-forms-for-one-to-many-relationships.md#input-id-implementation) it's unwieldy to use a single text input for multiple categories. We could type multiple category IDs into the input (e.g. "5, 2, 3, 6, 9"), but this is prone to human error, and the categories would have to be processed into an array server-side.

```html
<form action="/recipe/1/categories" method="POST">
  <input type="text" name="category_ids" />
  <input type="submit" value="Submit" />
</form>
```

Similar to one-to-many forms, we also want the user to choose from named options without worrying about record IDs.

## Input Relationship Data Using Checkboxes

![](../../.gitbook/assets/screen-shot-2020-11-24-at-4.29.59-pm.png)

One user-friendly way to manipulate many-to-many relationships is checkboxes. A checkbox is a UI element that represents zero or more selections. On the backend, we'll create a special route to associate categories with a given recipe.

#### GET Route for Recipe-Category Association Form

```javascript
app.get("/recipes/:id/categories/add", (request, response) => {
  pool.query("select * from categories", (error, result) => {
    const data = {
      categories: result.rows,
    };
    response.render("categories", data);
  });
});
```

#### EJS Template for Recipe-Category Association Form (categories.ejs)

```html
<form action="/recipe/<%= recipieId %>/categories" method="POST">
  <% categories.forEach((category) => { %>
  <label><%= category.name %></label>
  <input type="checkbox" name="category_ids" value="<%= category.id %>" />
  <% }); %>
  <input type="text" name="label" />
  <input type="submit" value="Submit" />
</form>
```

Notice that this is going to render a checkbox for each existing category. Every checkbox intentionally has the same `name` attribute to group the checkboxes together on form submission.

In our example of 3 categories, if all 3 categories are checked, the request will look like the following. Notice that the keys of the data being sent are the same each other, and the same as the `name` property of the checkbox form fields.

![](../../.gitbook/assets/screen-shot-2020-11-24-at-3.46.44-pm.png)

## Handle Checkbox Data in Backend

If multiple checkboxes are checked in the form, Express.js groups form inputs with the same key into an array. If only 1 checkbox is checked, `category_ids` will contain a single ID and not an array. If 0 checkboxes are checked, `request.body` will not contain a `category_ids` key.

```javascript
app.post("/recipie/:id/categories", (request, response) => {
  console.log(request.body.category_ids); // will be an array of numbers
  response.send("works");
});
```

Now we will loop over the array of selected categories and insert the relevant entries to our join table `recipe_categories` in the DB.

```javascript
app.post("/recipe/:id/categories", (request, response) => {
  console.log(request.body.category_ids);

  // get the recipe id url param
  const recipeId = request.params.id;

  const queryString =
    "INSERT INTO recipe_categories (recipe_id, category_id) VALUES ($1, $2)";

  // for each category we have in the request, make an insert query
  request.body.category_ids.forEach((categoryId, index) => {
    // construct the set of values we are inserting
    const values = [recipeId, categoryId];

    pool.query(queryString, values, (error, result) => {
      // query is done
      console.log(result);
    });
  });

  response.send("done");
});
```

Note that there is SQL syntax to insert multiple table entries with a single query, but `pg` does not support this elegantly. See more [here](https://github.com/brianc/node-postgres/issues/957).

## Respond When All Insert Query Callbacks Are Done

In our previous example we may have sent a response to the client before all queries were completed. This is because `pool.query` is asynchronous, and `response.send` may run before all `pool.query` calls have completed. Instead, we may wish to send a response only when all insert queries are done\*\*.\*\*

To do this, we add logic to determine that `category_ids.length` number of queries have finished. We can replace the `forEach` block and the subsequent `response.send` call from the previous example with the following code.

```javascript
let queryDoneCounter = 0;

// for each category we have in the request, make an insert query
request.body.category_ids.forEach((categoryId, index) => {
  // construct the set of values we are inserting
  const values = [recipeId, categoryId];

  pool.query(queryString, values, (error, result) => {
    // query is done
    console.log(result);

    // increment the counter, another query is done
    queryDoneCounter += 1;

    // check to see if all the queries are done
    if (queryDoneCounter === request.body.category_ids.length) {
      // TODO: check if any of the queries had errors.

      // all the queries are done, send a response.
      response.send("done!");
    }
  });
});
```

## Associate Categories On Recipe Creation

In addition to associating already-created recipes and categories, we may also want to associate recipes with categories at recipe creation. To do this, we'll add the above association logic to our recipe-creation logic.

In some sets of nested queries we need the result of an `INSERT` in order to proceed with the next query. Here on line 5 we are using `RETURNING *` at the end of our `INSERT` query so that we get back the primary key that was created.

```javascript
app.post("/recipe", (request, response) => {
  const recipeValues = [request.body.label];

  // use "RETURNING *" to retrieve the newly-created row
  const recipeInsertQuery =
    "INSERT INTO recipes (label) VALUES ($1) RETURNING *";

  // execute query to insert new recipe
  pool.query(recipeInsertQuery, recipeValues, (recipeError, recipeResult) => {
    if (recipeError) {
      response.status(501).send("error!");
      return;
    }

    // retrieving this data is possible because of the "RETURNING *" in our query
    const recipeId = recipeResult.rows[0].id;

    const categoryInsertQuery =
      "INSERT INTO recipe_categories (recipe_id, category_id) VALUES ($1, $2)";

    let queryDoneCounter = 0;

    // for each category we have in the request, make an insert query
    request.body.category_ids.forEach((categoryId, index) => {
      // construct the set of values we are inserting
      const categoryValues = [recipeId, categoryId];

      pool.query(
        categoryInsertQuery,
        categoryValues,
        (categoryError, categoryResult) => {
          // query is done
          console.log(categoryResult.rows);

          queryDoneCounter += 1;

          // all queries are done
          if (queryDoneCounter === request.body.category_ids.length) {
            response.send("done!");
          }
        }
      );
    });
  });
});
```



## Introduction

We saw with many-to-many relationships we can directly relate a given row in one table to any number of rows in another table and vice-versa. We accomplish this with a "join table", a table that contains only relational information. Now we'll expand our use of the join table to include data exclusive to the relationship between between the two joined tables.

## DB Initialisation

### Create Tables

Create `recipes`, `ingredients`, and their join table `recipe_ingredients`. Note that `recipe_ingredients` has a column called `measurement` that stores information specific to the _relationship_ between recipe and ingredient.

```sql
CREATE TABLE recipes ( id SERIAL PRIMARY KEY, label TEXT);
CREATE TABLE ingredients ( id SERIAL PRIMARY KEY, name TEXT);
CREATE TABLE recipe_ingredients ( id SERIAL PRIMARY KEY, recipe_id INTEGER, ingredient_id INTEGER, measurement TEXT);
```

### Create Recipes

Insert records to the `recipes` table.

```sql
INSERT INTO recipes ( label ) VALUES ('Udon');
INSERT INTO recipes ( label ) VALUES ('Mee Pok');
INSERT INTO recipes ( label ) VALUES ('Pasta');
```

### Create Ingredients

Insert records to the `ingredients` table.

```sql
INSERT INTO ingredients ( name ) VALUES ('fish ball');
INSERT INTO ingredients ( name ) VALUES ('soy sauce');
INSERT INTO ingredients ( name ) VALUES ('sesame oil');
```

## Add Associations and Relationship Data

### Check ID of Recipes and Ingredients

Retrieve IDs of recipes and ingredients to associate them in future queries.

```sql
SELECT * FROM recipes;
SELECT * FROM ingredients;
```

### Associate Recipes with Ingredients and Add Measurements

Imagine the following recipes have the following ingredients and measurements.

1. Udon recipe has 2 tablespoons of sesame oil and 1 tablespoon of soy sauce.
2. Mee Pok recipe has 4 fish balls and 2 tablespoons of sesame oil.

The `recipe_ingredients` table doesn't just represent a relationship between `recipes` and `ingredients` tables. It also has its own exclusive data, `measurement`. Both `recipe_id` and `ingredient_id` are foreign keys.

```sql
INSERT INTO recipe_ingredients ( recipe_id, ingredient_id, measurement ) VALUES (1, 2, '2 tbls');
INSERT INTO recipe_ingredients ( recipe_id, ingredient_id, measurement ) VALUES (1, 3, '1 tbls');
INSERT INTO recipe_ingredients ( recipe_id, ingredient_id, measurement ) VALUES (2, 1, '4');
INSERT INTO recipe_ingredients ( recipe_id, ingredient_id, measurement ) VALUES (2, 3, '2 tbls');
```

## Retrieve Relationship Data from Join Table

### Get All Recipe IDs With Soy Sauce

To retrieve all recipes with a given ingredient, we can consult the join table `recipe_ingredients`, because the join table has the relevant information. We can then use a join query on the join table and the `recipes` table to obtain the relevant recipes' information.

```sql
SELECT * FROM recipe_ingredients WHERE ingredient_id=2;
```

### Get All Recipes With Soy Sauce

To retrieve all recipes with a given ingredient, we can consult the join table `recipe_ingredients`, because the join table has the relevant information. We can then use a join query on the join table and the `recipes` table to obtain the relevant recipes' information.

```sql
SELECT recipes.label, recipe_ingredients.measurement
FROM recipes
INNER JOIN recipe_ingredients
ON recipes.id = recipe_ingredients.recipe_id
WHERE recipe_ingredients.ingredient_id=2
```

### Get Udon Ingredient IDs

Similarly, to retrieve all ingredients for a given recipe, we can also consult `recipe_ingredients`. We can use a join query on `recipe_ingredients` and `ingredients` to obtain the relevant ingredients' information.

```sql
SELECT * FROM recipe_ingredients WHERE recipe_id=1;
```

### Get Udon Ingredient Names

```sql
SELECT ingredients.name
FROM ingredients
INNER JOIN recipe_ingredients
ON ingredients.id = recipe_ingredients.ingredient_id
WHERE recipe_ingredients.recipe_id=1;
```
