# 3.2.1: SQL 1-M Relationships

## Learning Objectives

1. SQL relationships associate data between 1 or more SQL tables to model logical relationships and make data querying more modular and efficient
2. There are 2 kinds of relationships in SQL: one-to-many (1-M) and many-to-many (M-M)
3. Understand how SQL represents 1-M relationships in its databases
4. Understand how to collect data with 1-M relationships from frontends

## Introduction

Imagine a social media app with `Users` and `Posts` tables in its SQL database. How would the app know which posts belong to which users? The answer is SQL relationships.

To model the fact that each user can have 0 or more posts, but each post can belong to at most 1 user, we can implement a so-called one-to-many relationship (aka association) between users and posts.

SQL implements relationships using the concept of "primary" and "foreign" keys. Every table has a "primary key" (typically the `id` column) that uniquely identifies each row (aka record, entry) in the table. Tables can have columns that reference primary keys of related tables to define relationships between those tables. Primary keys referenced in other tables are known as "foreign keys", because from the perspective of the tables referencing the primary keys, those keys belongs to "foreign" tables.

The following is a sample `Users` table where `id` is the primary key. There are no foreign keys on this table.

| id (primary key) | username |
| ---------------- | -------- |
| 1                | foong    |
| 2                | kai      |

The following is a sample `Posts` table where `id` is also the primary key, but each post also belongs to a `User`, and specifies a `userId` to identify the user the post belongs to. `userId` is known as a "foreign key", because it references the "primary key" of another table.

| id (primary key) | text                      | userId (foreign key) |
| ---------------- | ------------------------- | -------------------- |
| 1                | "Go Rocket!!!!!!!!!!"     | 1                    |
| 2                | "Rocket is the Best!!!!!" | 1                    |
| 3                | "ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€ðŸš€"    | 2                    |

The foreign key always lives in the "many" table in the one-to-many relationship. In our above example, notice the foreign key lives in the `Posts` table and not the `Users` table, and it cannot be the other way around. If we tried to put a `postId` or `postIds` foreign key in the `Users` table, we would find that we would need to either duplicate `User` rows for each user's posts, or store an array of post IDs in the foreign key column. The former would repeat `User` data unnecessarily, and the latter would make SQL harder to query because of the array structure within a single cell of the table.

The above architecture of SQL relationships makes SQL efficient at storing data. The alternative might be to have a single `Posts` table where we store each `User`'s data repeatedly in every post, but that would be wasteful and inefficient, especially when our `Users` table contains more data such as contact information and preferences.

## Querying related data using SQL

Given the above `Users` and `Posts` tables, we can query for related data using primary and foreign key relationships.

For example, to query all posts that belong to `kai`, I could run 2 queries. The 1st query retrieves the `id` of the user with username `kai`.

```sql
SELECT id from Users where username='kai';
```

The above query would return `2`, `kai`'s user ID. The 2nd query retrieves the posts that belong to the user with that user ID, and should return all of `kai`'s posts.

```sql
SELECT * from Posts where userId=2;
```

We will not perform such queries with raw SQL in our apps, but we may need to perform such queries when performing analytics on our companies' databases outside of an app context. In our apps we typically use ORMs like Sequelize that make querying for related data more robust, with commands such as `user.getPosts()`. More on querying data with Sequelize in Sequelize submodules.

## Collecting user input for data with 1-M relationships

### Introduction

When we create new data and wish to associate that data to data in other tables, such as creating new recipes and associating them to categories, we need to have the user input the selected category when they create a recipe.

### Input ID Implementation

The naÃ¯ve way to do this is to create another text input for the user to input the relevant category's ID, but this isn't great because the user may not know what the categories are and what the categories' IDs are. We want to give the user the ability to select from all the possible categories and for the user not to have to deal with the IDs.

```html
<form action="/recipe" method="POST">
  <input type="text" name="label" />
  <input type="text" name="category_id" />
  <input type="submit" value="Submit" />
</form>
```

### Select from Dropdown Implementation

A recipe can only have one category, and the user has to choose from available categories, so we'll do this with a dropdown menu. A dropdown menu facilitates choosing from several selections, and our dropdown will only allow a single selection.

We need to populate this dropdown with all categories in the DB, so before we render the form we'll do a SQL query to get them.

### Query for Categories to Render Dropdown

When we send a GET request to render the create recipe form, we also query the DB for a list of all categories.

**index.js**

```javascript
app.get("/recipe/new", (request, response) => {
  pool.query("SELECT * from categories", (error, result) => {
    const data = {
      categories: result.rows,
    };
    response.render("recipe/new", data);
  });
});
```

### Render Dropdown

We can set the ID of each category in `option` tags in our form. The user never has to know which category names map to which category IDs.

**recipe/new.ejs**

```markup
<form action="/recipe" method="POST">
  <select name="category_id">
    <% categories.forEach((category) => { %>
    <option value="<%= category.id %>"><%= category.name %></option>
    <% }); %>
  </select>
  <input type="text" name="label" />
  <input type="submit" value="Submit" />
</form>
```

## Additional Resources

1. [Database normalisation theory](https://en.wikipedia.org/wiki/Database\_normalization) suggests ways to structure our SQL database to minimise redundancy. This is especially important for companies processing large volumes of data.
