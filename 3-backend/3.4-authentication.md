# 3.4: Authentication

## Learning Objectives

1. Understand the flow of typical authentication processes and how they use JWTs and cookies
2. Understand how to implement secure authentication with Auth0

## Introduction

Authentication is both simple and complex. The high-level concept of authenticating a user, then saving that user's authentic "badge" in their browser for subsequent requests is simple. But the lower-level concepts of how to authenticate and how to save that badge in the browser can be complex.

At Rocket Academy we will focus on the higher-level concepts of authentication, and let students dig deeper into the lower-level concepts themselves if time permits and students are interested. We will use [Auth0](https://auth0.com/) to implement authentication in our API servers, the industry standard for plug-and-play authentication libraries, comparable to Firebase Auth but with friendlier docs.

## Basic Authentication Flow

At a fundamental level, all authentication involves 3 steps.

1. User enters auth info such as username and password
2. Backend verifies auth info via cryptographic algorithm, typically involving [hashing](https://en.wikipedia.org/wiki/Cryptographic\_hash\_function) and [salting](https://en.wikipedia.org/wiki/Salt\_\(cryptography\)). Verification involves comparing the hashed version of the provided password with the hashed password stored in the database. We never store plain-text passwords for security reasons.
3. If auth info verified, backend sends user's browser a [cookie](https://en.wikipedia.org/wiki/HTTP\_cookie) that contains proof of authentication, typically either a [JSON web token](https://en.wikipedia.org/wiki/JSON\_Web\_Token) or a [session ID](https://en.wikipedia.org/wiki/Session\_ID) that cannot be forged. Browsers store cookies and send them to relevant websites, thereby proving authentication.

Authentication can be challenging because it involves many moving parts. Our server application must store auth info such as passwords and secret keys securely. Our cryptographic algorithm and proof of authentication must be industry-standard. Any bugs in logic or implementation can result in costly hacks.

This is why Rocket recommends we use a plug-and-play, industry-standard auth solution such as Auth0, and only write our own lower-level authentication logic when there is a strong business need and we have experts to test the robustness of our implementation.

## Implementing Authentication with Auth0

Luckily for us, companies such as Auth0 and Firebase have developed plug-and-play auth solutions that are both secure and easy to use. We will use Auth0 for backend authentication because Auth0 has clearer documentation for this use case.

### Setup Auth0 account and initial app

1. Create Auth0 account if we haven't already
   1. Yes, we will be the one coding
   2. No, we do not need advanced settings
2. Create Application
   1. Choose Single Page Web Application
   2. Choose React

### Review how to authenticate in React app

We should then be directed to a quickstart page like the following, populated with our app's specific domains and IDs. No need to implement anything for now, but read through to understand the high-level process.

{% embed url="https://auth0.com/docs/quickstart/spa/react/01-login" %}
Official Auth0 setup guide for React apps
{% endembed %}

1. Note application domain and client ID in Application Settings in the Auth0 dashboard. We will need to include these in our app to communicate with Auth0.
2. Configure callback and logout URLs to allow redirects back to our apps after logging in or out with Auth0
3. Configure allowed web origins to allow auth tokens (JWTs that serve as proof of authentication) to automatically refresh periodically after users have logged in to prevent auto-logout when auth tokens expire
4. Surround `App` component with `Auth0Provider` higher-order component to enable Auth0 in our apps. Note `Auth0Provider` uses React context underneath.
5. Add login to app with `loginWithRedirect` function from `useAuth0` React hook. Login is as simple as calling the function, letting users login in Auth0's interface, then redirecting back to our app.
6. Ditto with the `logout` function also from the `useAuth0` React hook. `returnTo: window.location.origin` tells Auth0 to redirect to the root URL of the current browser window after logging out.
7. Retrieve logged-in user profile information through the `user` property of the `useAuth0` hook. `user` contains properties such as `picture`, `name` and `email`.

That's all there is to logging in and out with Auth0 in our frontend! Let's now learn how to send that auth info to our backends for our users to access our backends securely.

### Review how to pass authentication info to API from React app

{% embed url="https://auth0.com/docs/quickstart/spa/react/02-calling-an-api" %}
Official Auth0 API-calling guide for React apps&#x20;
{% endembed %}

### Authorise access to specific routes in Express backend

{% embed url="https://auth0.com/docs/quickstart/backend/nodejs/01-authorization" %}
Official Auth0 route-authorisation guide for Express apps
{% endembed %}

Hopefully this gave us a clear high-level overview of what steps we need to implement Auth0 authentication in our frontends, how to send auth info in requests and protect our backends using Auth0 authorisation. We will get more hands-on practice with Auth0 in the upcoming hands-on auth exercise.
