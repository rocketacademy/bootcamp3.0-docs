# 0.4.6.1: Async Await

## Learning Objectives

1. Try-catch syntax allows us to handle errors from code in `try` blocks gracefully without crashing our apps

## Introduction

Conceptually, the following is how try-catch syntax works. When there is an error in a `try` block, e.g. a request to a nonexistent URL, the error will cause our program will crash unless we catch that error in a `catch` block.

```javascript
try {
  // Invalid URL will cause this function to throw an error
  axios.get("nonexistenturlabc123.com");
  // Catch block catches that error and allows us to handle it gracefully
} catch (error) {
  console.error(error);
  // Handle error gracefully
}
```

Try-catch can be useful in both frontend and backend code. In frontend, we can prevent erroneous API queries from crashing our app by gracefully letting our user know something went wrong. In backend, we can prevent erroneous database queries from crashing our server and gracefully return a 503 Server Error message instead of failing to respond to the client.

Try-catch syntax is not directly related to promises, but is commonly used together with async-await promise syntax (see [0.4.5.3: Async Await](0.4.6.1-async-await.md)). We will learn try-catch first before async-await. Our programs so far have not been complex enough to warrant try-catch, and we introduce it now that our programs send network requests with a higher likelihood of crashing our apps.

## What triggers the `catch` block?

An "**exception**" is a type of control flow that halts code flow and exits out of successive parent functions until it is caught and handled by a `catch` block. The goal of exceptions is to inform a higher level of the program of an error. If an exception is not handled, it causes the program to exit or crash. Most runtime errors trigger exceptions, e.g. accessing an invalid array index or object property.

### Example: Uncaught Exception

In the following examples we use the `throw` keyword to generate exceptions.

Here is what happens when we do not catch an exception.

{% code title="index.js" %}
```javascript
console.log("About to throw!");
throw "Throwed";
console.log("Threw");
```
{% endcode %}

When we run `index.js` we get the following output.

```
$ node index.js
About to throw!

index.js:2
throw "Throwed";
^
throwed
(Use `node --trace-uncaught ...` to show where the exception was thrown)
```

Notice the program crashed before the last `console.log`. Uncaught exceptions will end program execution no matter how many levels deep.

## Learning Objectives

1. How to use async-await syntax to manage promise control flow in lieu of `.then`
2. Async-await is cleaner syntax but functionally the same as `.then` syntax

## Introduction

`.then` syntax:

```javascript
// myFunc returns the return value of myFunc, currently undefined
const myFunc = () => {
  axios.get("foobar.com").then((data) => {
    // Do something with data after response received
    console.log(data);
  });
};
```

Async-await syntax:

```javascript
// myFunc returns a promise due to the async keyword
// The promise resolves to the return value of myFunc
const myFunc = async () => {
  const data = await axios.get("foobar.com");
  // Do something with data after response received
  console.log(data);
};
```

Async-await syntax allows us to write asynchronous JavaScript in a synchronous manner, like in the example above. `async` specifies a given function is asynchronous and returns a promise, and `await` will wait for a given promise to resolve before proceeding to the next line. `async` and `await` keywords must be used together; it is not meaningful to use `async` without `await`, and it is invalid to use `await` without `async`.

## Example: Async-await with `pg`

Async-await syntax is generally preferred due to its increased readability compared with `.then` syntax.

`.then` syntax:

```javascript
app.get('/users/:id', (request, response) => {
  const { id } = request.params;
  console.log('making query');
  pool.query('SELECT * FROM users WHERE id = $1', [id]).then((result) => {
    const { rows } = result;
    console.log('done with query');
    response.send(rows);
  };
});
```

Async-await syntax:

```javascript
app.get("/users/:id", async (request, response) => {
  const { id } = request.params;
  console.log("making query");
  const result = await pool.query("SELECT * FROM users WHERE id = $1", [id]);
  const { rows } = result;
  console.log("done with query");
  response.send(rows);
});
```

[Here](https://node-postgres.com/guides/async-express) are the official docs on how to use `pg` with async-await syntax in Express.

## Example: Catch errors with async-await

Try-catch syntax allows us to catch errors with async-await syntax in the same way we would catch errors with `.then` and `.catch` syntax.

`.then` syntax:

```javascript
const getRecipes = () => {
  // client is a Client instance from the Node pg library
  client
    // .query returns a promise
    .query("SELECT * from recipes WHERE category=vegan")
    .then((recipes) => {
      // Render the lovely vegan recipes
    })
    // The .catch block will trigger on error in either .query or .then block
    .catch((error) => {
      console.error(error);
      // Handle the error gracefully, e.g. render 404 page instead of crashing app
    });
};
```

Async-await syntax:

```javascript
const getRecipes = async () => {
  try {
    // client is a Client instance from the Node pg library
    const recipes = await client.query(
      "SELECT * from recipes WHERE category=vegan"
    );
    // Render the lovely vegan recipes
  } catch (error) {
    console.error(e);
    // Handle the error gracefully, e.g. render 404 page instead of crashing app
  }
};
```

## Example: Async-await does not pause programs, only code in current function

The following code executes "Before" and "After" `console.log`s before "Recipes".

```javascript
const getRecipes = async () => {
  try {
    // client is a Client instance from the Node pg library
    const recipes = await client.query(
      "SELECT * from recipes WHERE category=vegan"
    );
    // Render the lovely vegan recipes
    console.log("Recipes");
  } catch (error) {
    console.error(e);
    // Handle the error gracefully, e.g. render 404 page instead of crashing app
  }
};

console.log("Before");
getRecipes();
console.log("After");
```

Output

```
Before
After
Recipes
```

`getRecipes` will return before its logic has completed because it is an `async` function that contains an asynchronous `client.query`. `async` wraps `getRecipes` in a promise that returns immediately but resolves only when `getRecipes` logic is complete. Since there is no `.then` or `await` on the `getRecipes()` function call, the "After" `console.log` runs before `getRecipes` has resolved.

## Example: Retrieving unrelated data concurrently with async-await

We can use async-await with `Promise.all` to retrieve unrelated data concurrently with syntax that reads sequentially.

`.then` syntax:

```javascript
const getData = () => {
  const results = Promise.all([
    pool.query("SELECT * FROM recipes"),
    pool.query("SELECT * FROM categories"),
    pool.query("SELECT * FROM users"),
    // results is an array of results whose elements correspond
    // to the elements in the Promise.all parameter array
  ]).then((results) => {
    const [recipes, categories, users] = results;
    // Do something with recipes, categories and users
  });
};
```

Async-await syntax:

```javascript
const getData = async () => {
  // results is an array of results whose elements correspond
  // to the elements in the Promise.all parameter array
  const results = await Promise.all([
    pool.query("SELECT * FROM recipes"),
    pool.query("SELECT * FROM categories"),
    pool.query("SELECT * FROM users"),
  ]);
  const [recipes, categories, users] = results;
  // Do something with recipes, categories and users
};
```
