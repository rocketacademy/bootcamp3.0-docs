# 0.1.3: Reference vs Value

## Learning Objectives

1. Difference between mutable and immutable data types
2. Mutable data types are passed by reference and immutable data types passed by value
3. How to make an independent copy of a mutable data type

## Introduction

What will `array2.length` return in the final line?&#x20;

```javascript
var array1 = [1, 2, 3];
var array2 = array1;
array1.pop(); // Remove the last element from array1
console.log(array2.length);
```

`array2.length` above returns 2. We assigned `array2` to `array1` and arrays are mutable data types, hence `array2` references the same data as `array1`. Mutable data types are passed by reference and not by value.

If we wanted to copy `array1` into an independent `array2` variable, we could run the following code instead.

```javascript
var array1 = [1, 2, 3];
// "..." syntax in front of an array is called the spread operator
// The spread operator copies all elements in an array
// The surrounding [] encapsulates copies of array1's elements into a new array
var array2 = [...array1]; 
array1.pop(); // Remove the last element from array1
console.log(array2.length);
```

## Mutable and Immutable Data Types in JavaScript

Mutable data types are passed by reference. To make a copy we would use the JavaScript spread operator or a loop, not direct assignment to a new variable.

Immutable data types (aka primitive values) are passed by value. To make a copy we would assign the old variable to a new one, and any changes to either variable would not affect the other.

| Data type | Immutable / Mutable |
| --------- | ------------------- |
| Boolean   | Immutable           |
| Number    | Immutable           |
| String    | Immutable           |
| Array     | Mutable             |
| Object    | Mutable             |
| Function  | Mutable             |

## Mutable and Immutable Data Types in Computer Memory

Computers store data broadly in 2 places: memory (RAM) and drive (SSD or disk). Memory is smaller, faster storage and drive is larger, slower storage. Apps run in memory and persistent data is typically also stored in drive.

JavaScript references mutable data types with a memory address because we do not know beforehand how large these data structures will be. JS can store the value of immutable data types directly without a memory address because immutable data types have a fixed size.





## Memory

The word _memory_ in computing can have different meanings depending on the context. We'll discuss this JavaScript behaviour in the context of RAM memory, the part of the computer that holds variable values from the beginning to the end of the life of the program. (For instance RAM holds a global variable from `script.js` when the page loads until the window is refreshed or closed.)

The structure of RAM memory is like a grid that holds "primitive" values, i.e., numbers and strings. The terms 32-bit and 64-bit actually refers to the size of the values that can be held in one square of this memory grid.

This count variable can contain a value from 0 to 64 bit places (2⁶⁴), or 18,446,744,073,709,551,616 in base 10.

```javascript
var count = 15;
```

Think about the way an array or object can hold values- it's fundamentally different from holding a primitive value. This counts variable can hold an undetermined amount of number values that can each be from 0 to 18,446,744,073,709,551,616. It would be impossible for this single variable to fit in one square of the memory grid.

```javascript
var counts = [2, 5, 6, 7];
```

![Variables can hold primitive values or complex values.](../../.gitbook/assets/ref-v-value.jpg)

The way that JavaScript solves this is to hold one square for the variable itself, and then one square for each value it holds. This also allows for cases where an array contains another array, or other nested structures. Remember that there is no real limit on the _level of nesting_ of an array or object- e.g., an array that holds an array that holds an array, etc.

No need to worry for now how JavaScript manages to keep track and manage these values for use in an object or array. We'll cover the topic regarding objects in [DS\&A D.6.2: Hash Tables](../../algorithms/a.5-data-structures/a.5.2-hash-tables).

Video on computer memory: [https://www.youtube.com/watch?v=fVVrfJM4JeY](https://www.youtube.com/watch?v=fVVrfJM4JeY)

## Reference vs. Value

Now let's revisit the original example. When we assign the value of `array1` to a new variable `array2`, all we do is copy that reference to the array into a new variable. That reference still refers to the same squares.

When we run an operation on one variable, like pop, `array2` variable references the values from the original variable.

```javascript
var array1 = [1, 2, 3];
var array2 = array1;
array1.pop(); // get rid of one element of the array
array2.length; // this will be 2 - the same as array1
```

So, in this context, the word _**reference**_ is talking about the fact that an array variable _references_ the values inside.

Contrast this with variables that hold actual primitive values:

```javascript
var count = 2;
var count2 = count;
```

Line 2 above copies the value of the variable `count` into the new variable `count2`.

In the first example the `array1` reference is copied into the new variable `array2`.

Video on Reference vs Value: [https://www.youtube.com/watch?v=-hBJz2PPIVE](https://www.youtube.com/watch?v=-hBJz2PPIVE)

Video on how arrays are stored: [https://www.youtube.com/watch?v=pmN9ExDf3yQ](https://www.youtube.com/watch?v=pmN9ExDf3yQ)

### Fixes

How do we get around this behaviour? The solution depends on the data in the variable:

#### Simple fix: Non-nested values

If there are no arrays or objects in the variable, ES6 can be used.

```javascript
var array1 = [1, 2, 3];
var array2 = [...array1];
```

JS spread operator will make a copy of every value in the array into a new array. [See: 0.1.4](0.1.4-destructuring-and-spread-operator.md#example-make-shallow-copy-of-array) for more info.

#### Hack: Copy all nested values except functions

If you have data that is nested, like an array in an array, you can use this hack that makes the data into a string, then back into a variable value.

```javascript
var oldObject = {
  name: "A",
  address: {
    street: "Station Road",
    city: "Pune",
  },
};
var newObject = JSON.parse(JSON.stringify(oldObject));

newObject.address.city = "Delhi";
console.log("newObject");
console.log(newObject);
console.log("oldObject");
console.log(oldObject);
```

#### True "deep copy": Copy all values into a new copy

JavaScript doesn't provide any standard way of doing this, except for writing some kind of loop to go over the structure and create a new structure. See the links below for some examples.

## Further Reading

[https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript](https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript)\
\
[https://www.javascripttutorial.net/object/3-ways-to-copy-objects-in-javascript/](https://www.javascripttutorial.net/object/3-ways-to-copy-objects-in-javascript/)
